<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Feed App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f7f9;
        }
        .container {
            max-width: 600px;
            margin-top: 2rem;
        }
        .card {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 1.5rem;
        }
        .comment-button {
            transition: background-color 0.2s;
        }
        .comment-button:hover {
            background-color: #3b82f6;
        }
    </style>
    <script type="module">
        // Import necessary Firebase functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = null;
        let username = 'AnonymousUser';
        
        // This promise resolves ONLY after Firebase auth is complete and userId is set.
        let dbReadyResolve;
        const dbReadyPromise = new Promise(resolve => {
            dbReadyResolve = resolve;
        });

        // --- Utility Functions ---

        /**
         * Converts base64 PCM audio data to a playable WAV Blob.
         * @param {string} base64Data Base64 encoded PCM data.
         * @param {number} sampleRate Sample rate extracted from mimeType.
         * @returns {Blob} WAV audio blob.
         */
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcm16.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + dataSize, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;

            // FMT chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint33(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint33(offset, sampleRate, true); offset += 4;
            view.setUint33(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, bitsPerSample, true); offset += 2;

            // DATA chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint33(offset, dataSize, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        };

        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        /**
         * Plays the audio using a base64 encoded string and MIME type (L16 format).
         * @param {string} audioData Base64 encoded audio data.
         * @param {string} mimeType The full MIME type string (e.g., 'audio/L16;rate=24000').
         */
        const playAudio = async (audioData, mimeType) => {
            try {
                // Extract sample rate from mimeType (e.g., 'audio/L16;rate=24000')
                const rateMatch = mimeType.match(/rate=(\d+)/);
                if (!rateMatch) {
                    throw new Error("Could not extract sample rate from MIME type.");
                }
                const sampleRate = parseInt(rateMatch[1], 10);
                
                // Convert base64 to ArrayBuffer
                const pcmData = base64ToArrayBuffer(audioData);
                
                // API returns signed PCM16 audio data.
                const pcm16 = new Int16Array(pcmData);

                // Convert PCM to a WAV Blob
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                // Create object URL and play
                const audioUrl = URL.createObjectURL(wavBlob);
                const audio = new Audio(audioUrl);
                await audio.play();

            } catch (error) {
                console.error("Error playing audio:", error);
                showNotification(`Audio playback failed: ${error.message}`, 'error');
            }
        };

        // --- Firebase Initialization and Auth ---

        window.onload = async () => {
            // Set up Firebase logging for better debugging
            setLogLevel('Debug');

            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase configuration is missing. Cannot initialize the app.");
                return;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // 1. Initial Authentication
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Authentication failed:", error);
                // Fallback to anonymous sign-in if custom token fails
                await signInAnonymously(auth);
            }

            // 2. Set up Auth State Listener
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    username = `User-${userId.substring(0, 8)}`; // Set a simple default username
                    console.log("Authenticated as:", userId);
                    // Resolve the promise once we have the user ID
                    dbReadyResolve();
                    // Start listening for data now that auth is complete
                    listenForFeedUpdates();
                } else {
                    userId = null;
                    console.log("No user signed in.");
                }
            });
            
            // Set up event listeners for the TTS button
            document.getElementById('tts-button').addEventListener('click', generateAndPlayTTS);
            document.getElementById('submit-button').addEventListener('click', submitComment);
        };

        // --- Database Pathing and Data Fetching ---

        const getFeedCollectionPath = () => {
            // Public data path: /artifacts/{appId}/public/data/feed_comments
            return `artifacts/${appId}/public/data/feed_comments`;
        };
        
        const listenForFeedUpdates = () => {
            if (!db) {
                console.error("Firestore DB not initialized.");
                return;
            }

            const feedRef = collection(db, getFeedCollectionPath());
            
            // Query: order by timestamp descending
            const q = query(feedRef, orderBy("timestamp", "desc"));

            onSnapshot(q, (snapshot) => {
                const comments = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    comments.push({
                        id: doc.id,
                        ...data,
                        // Format the timestamp for display
                        displayTime: data.timestamp ? new Date(data.timestamp.toDate()).toLocaleString() : 'Just now'
                    });
                });
                renderFeed(comments);
            }, (error) => {
                console.error("Error listening to feed updates:", error);
                showNotification("Failed to connect to the live feed.", 'error');
            });
        };

        // --- Comment Submission ---

        const submitComment = async () => {
            const inputElement = document.getElementById('comment-input');
            const commentText = inputElement.value.trim();

            if (!commentText) {
                showNotification("Please enter a message to post.", 'warning');
                return;
            }
            
            // IMPORTANT: Wait for the database to be ready (auth complete)
            await dbReadyPromise; 

            if (!userId) {
                showNotification("Authentication not complete. Please wait a moment.", 'error');
                return;
            }

            try {
                const feedRef = collection(db, getFeedCollectionPath());
                
                await addDoc(feedRef, {
                    userId: userId,
                    username: username,
                    text: commentText,
                    timestamp: serverTimestamp() // Use server timestamp for accurate ordering
                });

                inputElement.value = ''; // Clear input on success
                showNotification("Comment posted successfully!", 'success');

            } catch (e) {
                console.error("Error submitting comment: ", e);
                showNotification(`Error posting comment: ${e.message}`, 'error');
            }
        };
        
        // --- TTS Generation and Playback ---
        
        const generateAndPlayTTS = async () => {
            const inputElement = document.getElementById('comment-input');
            const textToSpeak = inputElement.value.trim();

            if (!textToSpeak) {
                showNotification("Please enter a message to generate speech.", 'warning');
                return;
            }
            
            const ttsButton = document.getElementById('tts-button');
            const originalText = ttsButton.innerHTML;
            
            // Set loading state
            ttsButton.disabled = true;
            ttsButton.innerHTML = `
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Generating...
            `;
            
            // API Configuration
            const payload = {
                contents: [{
                    parts: [{ text: textToSpeak }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            // Using a clear, informative voice
                            prebuiltVoiceConfig: { voiceName: "Charon" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            try {
                let response = null;
                // Implement exponential backoff for robustness
                for (let i = 0; i < 3; i++) {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break;
                    } else if (response.status === 429 && i < 2) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    } else {
                        throw new Error(`API error: ${response.statusText}`);
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error("Failed to get a successful response from the TTS API.");
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    await playAudio(audioData, mimeType);
                    showNotification("Speech generated and played!", 'success');
                } else {
                    throw new Error("Invalid TTS response format or missing audio data.");
                }

            } catch (error) {
                console.error("TTS Generation Error:", error);
                showNotification(`TTS failed: ${error.message}`, 'error');
            } finally {
                // Restore button state
                ttsButton.disabled = false;
                ttsButton.innerHTML = originalText;
            }
        };


        // --- UI Rendering and Notifications ---
        
        const showNotification = (message, type) => {
            const notification = document.getElementById('notification');
            notification.innerHTML = message;
            notification.className = `p-3 mb-4 text-sm font-medium rounded-lg text-white ${type === 'success' ? 'bg-green-500' : type === 'warning' ? 'bg-yellow-500' : 'bg-red-500'}`;
            notification.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        };


        const renderFeed = (comments) => {
            const feedContainer = document.getElementById('feed-container');
            feedContainer.innerHTML = ''; // Clear existing comments

            if (comments.length === 0) {
                feedContainer.innerHTML = '<p class="text-center text-gray-500">No posts yet. Be the first to share!</p>';
                return;
            }

            comments.forEach(comment => {
                // Determine if the comment is from the current user
                const isCurrentUser = comment.userId === userId;
                
                const commentElement = document.createElement('div');
                commentElement.className = 'card p-4';
                
                commentElement.innerHTML = `
                    <div class="flex justify-between items-start">
                        <!-- User Info -->
                        <div>
                            <p class="text-sm font-semibold text-gray-900">${comment.username}</p>
                            <p class="text-xs text-gray-500 mb-2">ID: ${comment.userId}</p>
                        </div>
                        <!-- Timestamp -->
                        <div class="text-xs text-gray-400 mt-1">${comment.displayTime}</div>
                    </div>
                    
                    <!-- Content -->
                    <p class="text-gray-700 mt-2 whitespace-pre-wrap">${comment.text}</p>
                `;

                feedContainer.appendChild(commentElement);
            });
        };

        // Make functions globally accessible for HTML event attributes (if needed)
        window.submitComment = submitComment;
        window.generateAndPlayTTS = generateAndPlayTTS;

    </script>
</head>
<body class="min-h-screen">

    <!-- Navigation Bar (Minimal Header) -->
    <header class="bg-white shadow-md">
        <div class="max-w-6xl mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Community Buzz</h1>
            <div id="auth-status" class="text-sm text-gray-600">
                <!-- User status will be updated dynamically if needed -->
            </div>
        </div>
    </header>

    <!-- Main Content Container -->
    <div class="container mx-auto px-4">
        
        <!-- Notification Area -->
        <div id="notification" class="hidden" role="alert"></div>

        <!-- New Post Area -->
        <div class="card p-6 bg-blue-50">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Share Your Thoughts</h2>
            
            <textarea id="comment-input" rows="3" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="What's on your mind? (Use the TTS button to hear your message before posting!)"></textarea>
            
            <div class="mt-4 flex space-x-3 justify-end">
                
                <!-- TTS Button -->
                <button id="tts-button" class="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" aria-label="Generate and play speech for the input text">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M18 3a1 1 0 00-1.707-.707l-1.414 1.414A9.998 9.998 0 0010 2C5.03 2 1 6.03 1 11h2c0-3.86 3.14-7 7-7s7 3.14 7 7h2c0-4.97-4.03-9-9-9-3.32 0-6.315 1.472-8.385 3.82l-1.414-1.414A1 1 0 002 3V0h3zM3 17h14a1 1 0 000-2H3a1 1 0 000 2z" />
                    </svg>
                    TTS Preview
                </button>
                
                <!-- Submit Button -->
                <button id="submit-button" class="comment-button bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" aria-label="Post your comment to the feed">
                    Post Comment
                </button>
            </div>
        </div>

        <!-- Feed Container -->
        <h2 class="text-2xl font-bold text-gray-800 my-6">Latest Posts</h2>
        <div id="feed-container">
            <div class="text-center p-8 text-gray-500">
                <svg class="animate-spin h-5 w-5 mx-auto mb-2 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Loading posts...
            </div>
        </div>
        
    </div>
</body>
</html>
